


##################################################
# Building #######################################
##################################################

#------------------------------------------------#

build:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-build $(CabalOptions) $(CabalTargets)

	@echo ""
	@echo "=================================================="


.PHONY: build

#------------------------------------------------#

build-ghcjs:

	cabal new-build --project-file="./cabal-ghcjs.project" all

.PHONY: build-ghcjs

#------------------------------------------------#


#------------------------------------------------#

##################################################
# Testing ########################################
##################################################

#------------------------------------------------#

test:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-test $(CabalOptions) --enable-tests $(CabalTargets)

	@echo ""
	@echo "=================================================="

.PHONY: test

#------------------------------------------------#

bench:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-bench $(CabalOptions) --enable-benchmarks $(CabalTargets)

	@echo ""
	@echo "=================================================="

.PHONY: bench

#------------------------------------------------#



#------------------------------------------------#

##################################################
# Documentation ##################################
##################################################

#------------------------------------------------#

docs:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-haddock $(CabalOptions) --enable-documentation $(CabalTargets)

	@echo ""
	@echo "=================================================="
	@echo ""

	find $(BuildDirectory) -name "index.html" -print

	@echo ""
	@echo "=================================================="

.PHONY: docs

#------------------------------------------------#

##################################################
# Release ########################################
##################################################

#------------------------------------------------#

sdist:

	cabal new-build all
	cabal new-sdist all

#	(cd ./spiros  &&  cabal sdist)

.PHONY: sdist

##################################################



--------------------------------------------------

instance (NFData a) => NFData (Files a) where

--------------------------------------------------

deriving anyclass instance (Hashable a) => Hashable (Files a)

--------------------------------------------------

class NFData1 f where

A class of functors that can be fully evaluated.

Since: deepseq-1.4.3.0

liftRnf :: (a -> ()) -> f a -> ()

liftRnf should reduce its argument to normal form (that is, fully evaluate all sub-components), given an argument to reduce a arguments, and then return '()'.

--------------------------------------------------

instance NFData a => NFData [a] where rnf = rnf1

instance NFData1 [] where
    liftRnf r = go
      where
        go [] = ()
        go (x:xs) = r x `seq` go xs

--------------------------------------------------

toEV_byErroring

--------------------------------------------------

instance NFData1 Files where

  liftRnf :: (a -> ()) -> (Files a -> ())
  liftRnf rnf' = go

    where
    go _ = _

--------------------------------------------------

WhiteBlackList

--------------------------------------------------


{-|

'ChiaroscuroFilters' is a pair of filters (a blacklist and a whitelist)
of 'GlobPattern's.

@≡ 'These' 'emptyBlacklist' 'fullWhitelist'@

-}

newtype ChiaroscuroFilters = ChiaroscuroFilters

  (These Blacklist Whitelist)

--------------------------------------------------

{-| 

-}

type FilePathRegex = GlobPattern


--------------------------------------------------

type ChiaroscuroFilter = (Either GlobPattern GlobPattern)

--------------------------------------------------

import "these" Data.These (These(..))

--------------------------------------------------


{-| a blacklisted pattern.

= Implementation

@≡ 'Left'@

-}

blacklist :: GlobPattern -> ChiaroscuroFilter
blacklist = Left

{-| a whitelisted pattern.

= Implementation

@≡ 'Right'@

-}

whitelist :: GlobPattern -> ChiaroscuroFilter
whitelist = Right

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
blacklistChiaroscuroFilter = Set.singleton > go
  where

  go x = ChiaroscuroFilters (Blacklist x) mempty

whitelistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
whitelistChiaroscuroFilter = Set.singleton >
  go
  where

  go x = ChiaroscuroFilters mempty (Whitelist (Just x))

--------------------------------------------------

{-| a 'ChiaroscuroFilter' is a single value marked as either:

* blacklisted; or
* whitelisted.

-}

data ChiaroscuroFilter a = ChiaroscuroFilter

  { blacklisted :: !a
  , whitelisted :: !a
  }

  deriving stock    (Functor,Foldable,Traversable)

  deriving stock    (Generic,Lift)
  deriving stock    (Show,Read,Eq,Ord)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
blacklistChiaroscuroFilter = 

--------------------------------------------------

whitelistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
whitelistChiaroscuroFilter = 

--------------------------------------------------

{-| (utility function)

-}

fromFileKind
  :: FileKind
  -> (GlobPattern -> [FilePattern])

fromFileKind = \case

  RegularFile   -> RegularPattern   > (:[])
  DirectoryFile -> DirectoryPattern > (:[])
  AnyFile       -> mkBoth

  where
  mkBoth :: GlobPattern -> [FilePattern]
  mkBoth s = [RegularPattern s, DirectoryPattern s]

--------------------------------------------------

data FileKind

  = RegularFile
  | DirectoryFile
  | AnyFile

--------------------------------------------------

filterFilePaths :: FilePathFilters -> FindClause FilePath -> FindClause Bool
filterFilePaths = \case

  This  bs    -> filterBlacklist bs
  That  ws    -> filterWhitelist ws
  These bs ws -> filterBlacklist bs &&? filterWhitelist ws

--------------------------------------------------

filterFilesClause
  :: FileFilters
  -> (FindClause FilePath -> FindClause Bool)

filterFilesClause (ChiaroscuroFilters{ chiaroscuroBlacklist, chiaroscuroWhitelist }) =

  filterBlacklist chiaroscuroBlacklist &&? filterWhitelist chiaroscuroWhitelist

filterBlacklistClause
  :: Blacklist
  -> (FindClause FilePath -> FindClause Bool)

filterBlacklistClause (Blacklist bs) = go bs
  where

  go blacklist = \filepath ->

    all (filepath /~?) blacklist

filterWhitelistClause
  :: Whitelist
  -> (FindClause FilePath -> FindClause Bool)

filterWhitelistClause = \case

  Nothing             -> const (pure True)

  Just (Whitelist ws) -> go ws
  where

  go whitelist = \filepath ->

    any (filepath ~~?) whitelist

--------------------------------------------------

import qualified "containers" Data.Set as Set
import           "containers" Data.Set (Set)

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

import qualified "bytestring" Data.ByteString as B
--import qualified "bytestring" Data.ByteString.Lazy as B

--------------------------------------------------

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

--------------------------------------------------

  go = \case
      FileLocation filepath   -> BS.readFile filepath
      FileContents bytestring -> return bytestring

--------------------------------------------------

-- | wraps ''.

read :: (MonadIO m) =>  -> m (Text)
read () = do

  

  return $ ""

--------------------------------------------------

{-| An in-memory directory (with all its children files).

-}

type UTF8Directory = Directory Text

--------------------------------------------------

{-| An on-disk directory.

-}

type PathDirectory = Directory Void

--------------------------------------------------

{-|

NOTE: the "leaves" of this "file tree" must be 'File's;
thus, empty directories can't be represented (c.f. @git@).

-}

type Directory0 = Directory _

{-|

NOTE: the "leaves" of this "file tree" can be @Nothing@s;
thus, empty directories can be represented.

-}

type Directory1 = Directory _

--------------------------------------------------

data SrcDst = SrcDst

  { input  :: Src
  , output :: Dst
  }

--------------------------------------------------

>>> :set -XImplicitPrelude
>>> toConfig [] == Right defaultConfig
True
>>> toConfig [] == toConfig ["--subdir"]
True
>>> toConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", ".\/my-haskell-project-skeleton"] ])
Right (Config {verbosity = Verbose, filepath = Just ".\/my-haskell-project-skeleton", project = Nothing, subdirectory = PackageInRootDirectory})

:set -XPackageImports
:set -XImplicitPrelude
import qualified "optparse-applicative" Options.Applicative as P
parseConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", "./my-haskell-project-skeleton"] ])

    P.Failure (P.ParserFailure k) -> Left $ show (k "")

-- P.mkCompleter getCompletions

  <*> (P.flag PackageInNamesakeSubdirectory PackageInRootDirectory)
        ( P.long    "--no-subdir"
       <> P.metavar "SUBDIR?"
       <> P.help    "Whether the (singleton-package) project has (the default, without any flag) or doesn't have (with this flag) a separate subdirectory for its package."
       <> P.value
        )

--------------------------------------------------


{-|

-}

pBindingDefault :: Parser Binding
pBindingDefault = pBinding def

--------------------------------------------------

P.failureCode :: Int
 exit code — when a parse error occurs.

P.headerDoc   
P.progDescDoc ""
P.footerDoc   

--------------------------------------------------

data Config f = Config

  { verbosity    :: f Verbosity
  , license      :: f License
  , actions      :: Action f
  }

--------------------------------------------------

{-| 

-}

mkLocation projectpath projectname = getFirst $ sconcat

  [ First projectpath
  , First projectname
  , First def
  ]

--------------------------------------------------

programVersion :: Version
programVersion = Version

  { versionBranch = (majorVersion ++ minorVersion)
  , versionTags   = []
  }

  where

  majorVersion = [0,1]
  minorVersion = [0]

versionBranch = [a,b,c]

--------------------------------------------------

import           "base" Data.Maybe
import           "base" Data.Semigroup

--------------------------------------------------


#	@mkdir -p "./bin/bash_completion.d"
#
#	@touch "./bin/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/$(DefaultExecutableProgram)"
#
#	@touch "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-build "skeletor:exe:$(DefaultExecutableProgram)"
#
#	ln -sf `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` "./bin/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-exec -- $(DefaultExecutableProgram) --bash-completion-script `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` > "./bin/bash_completion.d/$(DefaultExecutableProgram)"

--------------------------------------------------

##################################################
package:

# ^ a package generated by « cabal2nix »'s,
# or any package which looks like: « {mkDerivation, base, ...}: mkDerivation { ... } ».

--------------------------------------------------

{

  cabal-project-file = import ./cabal.project.nix {};

  nix-derviation = import ./skeletor.nix arguments;

}

--------------------------------------------------

static-shell:

	@echo '=================================================='
	@echo

	@$(NixBuild)  "./nix/static"  -o "./result-static"

	@echo
	@echo '=================================================='

.PHONY: static-shell

--------------------------------------------------

arguments@

{ nixpkgs  ? <nixpkgs>
, overlays ? []
, config   ? {}

, pkgs     ? (import nixpkgs { inherit overlays config; }).pkgsMusl
           # ^ « musl » as C Library, not « glibc ».

, compiler ? "ghc844"
           # ^ GHC 8.4.4

, strip    ? true
}:

--------------------------------------------------

cabal error:

    ~/haskell/spiros$ hba
    Resolving dependencies...
    Map.!: given key is not an element in the map
    CallStack (from HasCallStack):
      error, called at libraries/containers/Data/Map/Internal.hs:610:17 in containers-0.5.11.0:Data.Map.Internal

cause: undeclared flag

--------------------------------------------------


options :: P.Parser Options
options = do

  let knownProjectNames = builtinProjectNames

  verbosity <- (P.flag Concise Verbose) (mconcat

        [ embolden (P.long    "verbose")
        , embolden (P.short   'v')
        , P.help    "Enable verbose messages. (Includes printing the config that's derived from the invokation of this command: ① parsing these command-line options; and ② defaulting the values of any optional options)."
        ])

  dryrun <- (P.flag TrueRun DryRun) (mconcat

        [ embolden (P.long    "dryrun")
        , embolden (P.short   'i')
        , P.help    "Whether the execution will just be a 'dry-run' (i.e. effects are disabled, instead they are printed out)."
        ])

  printVersion <- empty

     <|> (P.switch (mconcat

        [ embolden (P.long    "print-version")
        , P.help    "Print the version of this program. The format is, for example, « 0.0.0 ». No other text is printed."
        ]))

     <|> (P.switch (mconcat

        [ embolden (P.long    "version")
        , P.help    "Alias for « --print-version »."
        ]))

  printLicense <- P.switch (mconcat   -- TODO -- subcommand, not option.

        [ embolden (P.long    "print-license")
        , P.help    "Print the SPDX license identifier of this program, then print out the license text."
        ])

  printConfig <- P.switch (mconcat
        [ embolden (P.long    "print-config")
        , P.internal                  -- .hidden
        , P.help    "[INTERNAL] Print the internal configuration which the command-line options are parsed into."
        ])

  resolveConfiguration <- P.switch (mconcat [])

  projectpath <- optional (P.strOption (mconcat

        [ embolden (P.long    "project-filepath")
        , embolden (P.short   'f')
        , italicize (P.metavar "PROJECT_PATH")
        , P.action  "directory"
        , P.help    "Which project skeleton, by path. (When both « --project-filepath » and « --project-name » are given, this option takes precedence. When neither are given, the default value equivalent to « --project-name=default »)."
        ]))

  projectname <- optional (P.strOption (mconcat

        [ embolden (P.long    "project-name")
        , embolden (P.short   'p')
        , italicize (P.metavar "PROJECT_NAME")
        , P.completeWith builtinProjectNames
        , P.help    "Which project skeleton, by name. (Press the « TAB » key for shell-completion of known projects)."
        ]))

  subdirectory <- optional (P.strOption (mconcat
        [ embolden (P.long    "subdir")
        , P.action  "file"
        , P.help    "The subdirectory of the « --location » (when unpacked)."
        ]))

  configpath <- optional (P.strOption (mconcat

        [ embolden (P.long    "config")
        , embolden (P.short   'c')
        , italicize (P.metavar "CONFIG_FILE")
        , P.action  "file"
        , P.help    "Non-Command-Line Options & Arguments — most (but not all) options can be passed via an « INI » file (c.f. a UNIX-style « .conf » file). Relative filepaths are interpreted relative: to ① the current directory from which this command was invoked; ② to the XDG configuraton directories (both global and user). Absolute filepaths are accepted too. NOTE any explicit Command-Line options override any options written in CONFIG_FILE."
        ]))

  bindings <- many (P.option rBinding (mconcat

        [ embolden (P.long    "binding")
        , embolden (P.short   'b')
        , italicize (P.metavar "VARIABLE_BINDING")
        , P.help    "A configuration variable binding. e.g. « -b \"name=Sam Boosalis\" » (NOTE the quotes are stripped from the argument by the shell, they group the « name=value » into a single argument, when the « value » has whitespace.)."
        ]))

  environment <- defaulting [] (P.option rBindings (mconcat

        [ embolden (P.long    "bindings")
        , embolden (P.short   'e')
        , italicize (P.metavar "VARIABLE_BINDING...")
        , P.help    "A set of configuration variable bindings. e.g. « -e 'user=sboosali:name=Sam Boosalis:' ». one « --bindings _ » is equivalent to multiple « --binding _ --binding _ ...»."
        ]))

  license <- defaulting "BSD-3-Clause" (P.strOption (mconcat

        [ embolden (P.long    "license")
        , embolden (P.metavar "LICENSE")
        , P.completeWith knownLicenseIds
        , P.help    "The PROJECTS's spdx license identifier."
        ]))

  return Options{..}

--------------------------------------------------

licenseOption :: License
licenseOption = 
  license <- defaulting "BSD-3-Clause" (P.strOption (mconcat

        [ (P.long    "license")
        , (P.metavar "LICENSE")
        , P.completeWith knownLicenseIds
        , P.help    "The PROJECTS's spdx license identifier."
        , P.style P.bold
        ]))

--------------------------------------------------

  where

  defaulting x p = maybe x id <$> optional p

  embolden  = (<> P.style P.bold)
  italicize = (<> P.style P.underline)

--------------------------------------------------

pCommand :: P.Parser Command
pCommand = empty

  <|> (P.hsubparser (CommandCreateProject        <$> pCreateProjectOptions))
  <|> (P.hsubparser (CommandDownloadProject      <$> pDownloadProjectOptions))
  <|> (P.hsubparser (CommandResolveConfiguration <$> pResolveConfigurationOptions))

--------------------------------------------------

pCommand :: P.Parser Command
pCommand = P.hsubparser p
  where

  p = empty

    <|> (P.command (CommandCreateProject        <$> pCreateProjectOptions))
    <|> (P.command (CommandDownloadProject      <$> pDownloadProjectOptions))
    <|> (P.command (CommandResolveConfiguration <$> pResolveConfigurationOptions))


--------------------------------------------------
-- Parsers ---------------------------------------
--------------------------------------------------

pURI :: P.ReadM URI
pURI = _

--------------------------------------------------

pProject :: P.ReadM Project
pProject = _

--------------------------------------------------

pLicense :: P.ReadM License
pLicense = _

--------------------------------------------------

pLocation :: P.ReadM Location
pLocation = _

--------------------------------------------------

pFetchBy :: P.ReadM FetchBy
pFetchBy = _

--------------------------------------------------

rBindings :: P.ReadM Bindings
rBindings = P.eitherReader (A.parseOnly p . T.pack)
  where

  p = pBindings bindingSyntax

--------------------------------------------------

rBinding :: P.ReadM Binding
rBinding = P.eitherReader (A.parseOnly p . T.pack)
  where

  p = pBinding bindingSyntax

--------------------------------------------------

rLicense :: P.ReadM License
rLicense = P.maybeReader parseSpdxLicenseIdentifier

--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------
