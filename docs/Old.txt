--------------------------------------------------

instance (NFData a) => NFData (Files a) where

--------------------------------------------------

deriving anyclass instance (Hashable a) => Hashable (Files a)

--------------------------------------------------

class NFData1 f where

A class of functors that can be fully evaluated.

Since: deepseq-1.4.3.0

liftRnf :: (a -> ()) -> f a -> ()

liftRnf should reduce its argument to normal form (that is, fully evaluate all sub-components), given an argument to reduce a arguments, and then return '()'.

--------------------------------------------------

instance NFData a => NFData [a] where rnf = rnf1

instance NFData1 [] where
    liftRnf r = go
      where
        go [] = ()
        go (x:xs) = r x `seq` go xs

--------------------------------------------------

toEV_byErroring

--------------------------------------------------

instance NFData1 Files where

  liftRnf :: (a -> ()) -> (Files a -> ())
  liftRnf rnf' = go

    where
    go _ = _

--------------------------------------------------

WhiteBlackList

--------------------------------------------------


{-|

'ChiaroscuroFilters' is a pair of filters (a blacklist and a whitelist)
of 'GlobPattern's.

@≡ 'These' 'emptyBlacklist' 'fullWhitelist'@

-}

newtype ChiaroscuroFilters = ChiaroscuroFilters

  (These Blacklist Whitelist)

--------------------------------------------------

{-| 

-}

type FilePathRegex = GlobPattern


--------------------------------------------------

type ChiaroscuroFilter = (Either GlobPattern GlobPattern)

--------------------------------------------------

import "these" Data.These (These(..))

--------------------------------------------------


{-| a blacklisted pattern.

= Implementation

@≡ 'Left'@

-}

blacklist :: GlobPattern -> ChiaroscuroFilter
blacklist = Left

{-| a whitelisted pattern.

= Implementation

@≡ 'Right'@

-}

whitelist :: GlobPattern -> ChiaroscuroFilter
whitelist = Right

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
blacklistChiaroscuroFilter = Set.singleton > go
  where

  go x = ChiaroscuroFilters (Blacklist x) mempty

whitelistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
whitelistChiaroscuroFilter = Set.singleton >
  go
  where

  go x = ChiaroscuroFilters mempty (Whitelist (Just x))

--------------------------------------------------

{-| a 'ChiaroscuroFilter' is a single value marked as either:

* blacklisted; or
* whitelisted.

-}

data ChiaroscuroFilter a = ChiaroscuroFilter

  { blacklisted :: !a
  , whitelisted :: !a
  }

  deriving stock    (Functor,Foldable,Traversable)

  deriving stock    (Generic,Lift)
  deriving stock    (Show,Read,Eq,Ord)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
blacklistChiaroscuroFilter = 

--------------------------------------------------

whitelistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
whitelistChiaroscuroFilter = 

--------------------------------------------------

{-| (utility function)

-}

fromFileKind
  :: FileKind
  -> (GlobPattern -> [FilePattern])

fromFileKind = \case

  RegularFile   -> RegularPattern   > (:[])
  DirectoryFile -> DirectoryPattern > (:[])
  AnyFile       -> mkBoth

  where
  mkBoth :: GlobPattern -> [FilePattern]
  mkBoth s = [RegularPattern s, DirectoryPattern s]

--------------------------------------------------

data FileKind

  = RegularFile
  | DirectoryFile
  | AnyFile

--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------
