











--------------------------------------------------
--------------------------------------------------

{-|




-}

module Program.Xxx_Module_xxX.Paths

  ( -- * Application Metadata

    subdirectory_Xxx_Program_xxX
  , name_Xxx_Program_xxX
  , version_Xxx_Program_xxX

  -- * Application-Specific Directories

  {- |

The @getMyApplication{Config,Data,Cache}Directory@ operations
return this application's (platform-specific, user-writeable) directory
for @{configuration files, data files, caching}@.

The @getMyApplication{Config,Data,Cache}Directory@ operations may throw these exceptions (all 'System.IO.IOError's):

* @System.IO.HardwareFault@
A physical I\/O error has occurred.
@[EIO]@

* 'System.IO.isDoesNotExistError'
There is no path referring to the working directory.
@[EPERM, ENOENT, ESTALE...]@

* 'System.IO.isPermissionError'
The process has insufficient privileges to perform the operation.
@[EACCES]@

* 'System.IO.isFullError'
Insufficient resources are available to perform the operation.

* @UnsupportedOperation@
The operating system has no notion of current working directory.

  -}

  , getMyApplicationDataDirectory
  , getMyApplicationConfigDirectory
  , getMyApplicationCacheDirectory

  ) where

--------------------------------------------------
-- Imports ---------------------------------------
--------------------------------------------------

import Program.Xxx_Module_xxX.Prelude

--------------------------------------------------

import qualified "filepath"  System.FilePath  as File

--------------------------------------------------

import qualified "directory" System.Directory as Directory

--------------------------------------------------

import qualified "base" Data.Version as Version
import           "base" Data.Version (Version)

import qualified "base" System.Info  as IO

--------------------------------------------------
-- Definitions -----------------------------------
--------------------------------------------------

name_Xxx_Program_xxX :: ApplicationName
name_Xxx_Program_xxX = "My Application"

--------------------------------------------------

version_Xxx_Program_xxX :: Version
version_Xxx_Program_xxX = "0.0.0"

--------------------------------------------------
--------------------------------------------------

subdirectory_Xxx_Program_xxX :: IO FilePath
subdirectory_Xxx_Program_xxX = do

  platform <- getRuntimeApplicationPlatform

  let directory = subdirectoryOfMyApplicationFor platform

  return directory

--------------------------------------------------
--------------------------------------------------

-- | Return this application's (platform-specific, user-writeable) configuration directory.

getMyApplicationDataDirectory :: FilePath -> IO FilePath
getMyApplicationDataDirectory = getMyApplicationDirectoryFor Directory.XdgData

--------------------------------------------------

-- | Return this application's (platform-specific, user-writeable) data directory.

getMyApplicationConfigDirectory :: FilePath -> IO FilePath
getMyApplicationConfigDirectory = getMyApplicationDirectoryFor Directory.XdgConfig

--------------------------------------------------

-- | Return this application's (platform-specific, user-writeable) cache.

getMyApplicationCacheDirectory :: FilePath -> IO FilePath
getMyApplicationCacheDirectory = getMyApplicationDirectoryFor Directory.XdgCache

--------------------------------------------------
-- Utilities -------------------------------------
--------------------------------------------------

-- | 

getMyApplicationDirectoryFor :: Directory.XdgDirectory -> FilePath -> IO FilePath
getMyApplicationDirectoryFor xdg path = do

  subdirectory <- subdirectory_Xxx_Program_xxX

  let relativePath = subdirectory File.</> path

  xdgPath <- Directory.getXdgDirectory xdg relativePath

  absolutePath <- Directory.makeAbsolute xdgPath

  return absolutePath

--createDirectoryIfMissing

--------------------------------------------------
--------------------------------------------------

type ApplicationName = String

--------------------------------------------------

{- | Return this application's (platform-specific, user-writeable) subdirectory (a.k.a. namespace), given:

* the application name        — @"Foo App"@
* the application institution — @"Mondragon"@
* the application website     — @"Mondragon.com"@

For example, given an application named @Foo App@ by company @Mondragon@ with web address @Mondragon.co.uk@:

* @"fooapp/"@                on Linux   — i.e. lower-cased, no spaces
* @"MegaCrop\Foo App\"@      on Windows — i.e. two folders, @Mondragon.com@ and @Foo App\@.
* @"com.Mondragon.Foo-App/"@ on MacOS   — i.e. invalid characters are replaced with @-@.

See <https://stackoverflow.com/questions/43853548/xdg-basedir-directories-for-windows>.

-}

subdirectoryOfMyApplicationFor :: ApplicationPlatform -> FilePath
subdirectoryOfMyApplicationFor = \case

  PosixPlatform     -> thePosixApplicationDirectory
  WindowsPlatform   -> theWindowsApplicationDirectory
  MacintoshPlatform -> theMacintoshApplicationDirectory

  where

  thePosixApplicationDirectory     = "myapplication/"

  theWindowsApplicationDirectory   = "sboosali/My Application/"

  theMacintoshApplicationDirectory = "io.sboosali.My-Application/"

--------------------------------------------------
--------------------------------------------------

data ApplicationPlatform

  = PosixPlatform
  | WindowsPlatform
  | MacintoshPlatform

--------------------------------------------------

getRuntimeApplicationPlatform :: IO (Maybe ApplicationPlatform)
getRuntimeApplicationPlatform = do

  return IO.os >>= \case

    "linux"   -> Just PosixPlatform

    "mingw32" -> Just WindowsPlatform
    "mingw64" -> Just WindowsPlatform

    "darwin"  -> Just MacintoshPlatform

    _         -> Nothing

--------------------------------------------------
-- EOF -------------------------------------------
--------------------------------------------------










































--------------------------------------------------
--------------------------------------------------

{-| 

-}

module MyApplication.Paths

  ( directoryMyApplication

  , nameOfMyApplication
  , versionOfMyApplication

  , getMyApplicationDataDirectory
  , getMyApplicationConfigDirectory
  , getMyApplicationCacheDirectory

  ) where

--------------------------------------------------
-- Imports ---------------------------------------
--------------------------------------------------

import qualified "directory" System.Directory as Directory

--------------------------------------------------

import qualified "base" Data.Version as Version
import           "base" Data.Version (Version)

import qualified "base" System.Info  as IO

--------------------------------------------------

import qualified "base" Prelude
import           "base" Prelude

--------------------------------------------------
-- Definitions -----------------------------------
--------------------------------------------------

directoryMyApplication :: FilePath
directoryMyApplication = renderApplicationDirectoryFor

--------------------------------------------------

-- | 

getMyApplicationDataDirectory :: FilePath -> IO FilePath
getMyApplicationDataDirectory = getMyApplicationDirectoryFor Directory.XdgData

--------------------------------------------------

-- | 

getMyApplicationConfigDirectory :: FilePath -> IO FilePath
getMyApplicationConfigDirectory = getMyApplicationDirectoryFor Directory.XdgConfig

--------------------------------------------------

-- | 

getMyApplicationCacheDirectory :: FilePath -> IO FilePath
getMyApplicationCacheDirectory = getMyApplicationDirectoryFor Directory.XdgCache

--------------------------------------------------
-- Utilities -------------------------------------
--------------------------------------------------

-- | 

getMyApplicationDirectoryFor :: Directory.XdgDirectory -> FilePath -> IO FilePath
getMyApplicationDirectoryFor = \case

  Directory.XdgData   -> dataFile

  Directory.XdgConfig -> configFile

  Directory.XdgCache  -> cacheFile

  where

  dataFile file = do

    return file

  configFile file = do

    return file

  cacheFile file = do

    return file

--------------------------------------------------

{- | Return a platform-specific and application-specific directory for user-writeable data\/configs\/caches.

For example, given an application named @Foo App@ by company @MegaCorp@ with web address @MegaCorp.co.uk@:

* @"fooapp/"@                 on Linux   — i.e. lower-cased, no spaces
* @"MegaCrop\Foo App\"@       on Windows — i.e. two folders, @MegaCrop@ and @Foo App\@.
* @"uk.co.MegaCorp.Foo-App/"@ on MacOS   — i.e. invalid characters are replaced with @-@.

See <https://stackoverflow.com/questions/43853548/xdg-basedir-directories-for-windows>.

renderApplicationDirectoryFor :: ApplicationName -> IO FilePath
renderApplicationDirectoryFor = \case

  PosixPlatform     -> name
  WindowsPlatform   -> name
  MacintoshPlatform -> name

--------------------------------------------------

nameOfMyApplication :: ApplicationName
nameOfMyApplication = Prelude.words "my application"

--------------------------------------------------

versionOfMyApplication :: Version
versionOfMyApplication = "0.0.0"

--------------------------------------------------

type ApplicationName = [String]

--------------------------------------------------

data ApplicationPlatform

  = PosixPlatform
  | WindowsPlatform
  | MacintoshPlatform

--------------------------------------------------

getRuntimeApplicationPlatform :: IO (Maybe ApplicationPlatform)
getRuntimeApplicationPlatform = do

  return IO.os >>= \case

    "linux"   -> Just PosixPlatform

    "mingw32" -> Just WindowsPlatform
    "mingw64" -> Just WindowsPlatform

    "darwin"  -> Just MacintoshPlatform

    _         -> Nothing

--------------------------------------------------
-- EOF -------------------------------------------
--------------------------------------------------





















##################################################
# Building #######################################
##################################################

#------------------------------------------------#

build:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-build $(CabalOptions) $(CabalTargets)

	@echo ""
	@echo "=================================================="


.PHONY: build

#------------------------------------------------#

build-ghcjs:

	cabal new-build --project-file="./cabal-ghcjs.project" all

.PHONY: build-ghcjs

#------------------------------------------------#


#------------------------------------------------#

##################################################
# Testing ########################################
##################################################

#------------------------------------------------#

test:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-test $(CabalOptions) --enable-tests $(CabalTargets)

	@echo ""
	@echo "=================================================="

.PHONY: test

#------------------------------------------------#

bench:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-bench $(CabalOptions) --enable-benchmarks $(CabalTargets)

	@echo ""
	@echo "=================================================="

.PHONY: bench

#------------------------------------------------#



#------------------------------------------------#

##################################################
# Documentation ##################################
##################################################

#------------------------------------------------#

docs:

	@echo "=================================================="
	@echo ""

	$(Cabal) new-haddock $(CabalOptions) --enable-documentation $(CabalTargets)

	@echo ""
	@echo "=================================================="
	@echo ""

	find $(BuildDirectory) -name "index.html" -print

	@echo ""
	@echo "=================================================="

.PHONY: docs

#------------------------------------------------#

##################################################
# Release ########################################
##################################################

#------------------------------------------------#

sdist:

	cabal new-build all
	cabal new-sdist all

#	(cd ./spiros  &&  cabal sdist)

.PHONY: sdist

##################################################



--------------------------------------------------

instance (NFData a) => NFData (Files a) where

--------------------------------------------------

deriving anyclass instance (Hashable a) => Hashable (Files a)

--------------------------------------------------

class NFData1 f where

A class of functors that can be fully evaluated.

Since: deepseq-1.4.3.0

liftRnf :: (a -> ()) -> f a -> ()

liftRnf should reduce its argument to normal form (that is, fully evaluate all sub-components), given an argument to reduce a arguments, and then return '()'.

--------------------------------------------------

instance NFData a => NFData [a] where rnf = rnf1

instance NFData1 [] where
    liftRnf r = go
      where
        go [] = ()
        go (x:xs) = r x `seq` go xs

--------------------------------------------------

toEV_byErroring

--------------------------------------------------

instance NFData1 Files where

  liftRnf :: (a -> ()) -> (Files a -> ())
  liftRnf rnf' = go

    where
    go _ = _

--------------------------------------------------

WhiteBlackList

--------------------------------------------------


{-|

'ChiaroscuroFilters' is a pair of filters (a blacklist and a whitelist)
of 'GlobPattern's.

@≡ 'These' 'emptyBlacklist' 'fullWhitelist'@

-}

newtype ChiaroscuroFilters = ChiaroscuroFilters

  (These Blacklist Whitelist)

--------------------------------------------------

{-| 

-}

type FilePathRegex = GlobPattern


--------------------------------------------------

type ChiaroscuroFilter = (Either GlobPattern GlobPattern)

--------------------------------------------------

import "these" Data.These (These(..))

--------------------------------------------------


{-| a blacklisted pattern.

= Implementation

@≡ 'Left'@

-}

blacklist :: GlobPattern -> ChiaroscuroFilter
blacklist = Left

{-| a whitelisted pattern.

= Implementation

@≡ 'Right'@

-}

whitelist :: GlobPattern -> ChiaroscuroFilter
whitelist = Right

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
blacklistChiaroscuroFilter = Set.singleton > go
  where

  go x = ChiaroscuroFilters (Blacklist x) mempty

whitelistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
whitelistChiaroscuroFilter = Set.singleton >
  go
  where

  go x = ChiaroscuroFilters mempty (Whitelist (Just x))

--------------------------------------------------

{-| a 'ChiaroscuroFilter' is a single value marked as either:

* blacklisted; or
* whitelisted.

-}

data ChiaroscuroFilter a = ChiaroscuroFilter

  { blacklisted :: !a
  , whitelisted :: !a
  }

  deriving stock    (Functor,Foldable,Traversable)

  deriving stock    (Generic,Lift)
  deriving stock    (Show,Read,Eq,Ord)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
blacklistChiaroscuroFilter = 

--------------------------------------------------

whitelistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
whitelistChiaroscuroFilter = 

--------------------------------------------------

{-| (utility function)

-}

fromFileKind
  :: FileKind
  -> (GlobPattern -> [FilePattern])

fromFileKind = \case

  RegularFile   -> RegularPattern   > (:[])
  DirectoryFile -> DirectoryPattern > (:[])
  AnyFile       -> mkBoth

  where
  mkBoth :: GlobPattern -> [FilePattern]
  mkBoth s = [RegularPattern s, DirectoryPattern s]

--------------------------------------------------

data FileKind

  = RegularFile
  | DirectoryFile
  | AnyFile

--------------------------------------------------

filterFilePaths :: FilePathFilters -> FindClause FilePath -> FindClause Bool
filterFilePaths = \case

  This  bs    -> filterBlacklist bs
  That  ws    -> filterWhitelist ws
  These bs ws -> filterBlacklist bs &&? filterWhitelist ws

--------------------------------------------------

filterFilesClause
  :: FileFilters
  -> (FindClause FilePath -> FindClause Bool)

filterFilesClause (ChiaroscuroFilters{ chiaroscuroBlacklist, chiaroscuroWhitelist }) =

  filterBlacklist chiaroscuroBlacklist &&? filterWhitelist chiaroscuroWhitelist

filterBlacklistClause
  :: Blacklist
  -> (FindClause FilePath -> FindClause Bool)

filterBlacklistClause (Blacklist bs) = go bs
  where

  go blacklist = \filepath ->

    all (filepath /~?) blacklist

filterWhitelistClause
  :: Whitelist
  -> (FindClause FilePath -> FindClause Bool)

filterWhitelistClause = \case

  Nothing             -> const (pure True)

  Just (Whitelist ws) -> go ws
  where

  go whitelist = \filepath ->

    any (filepath ~~?) whitelist

--------------------------------------------------

import qualified "containers" Data.Set as Set
import           "containers" Data.Set (Set)

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

import qualified "bytestring" Data.ByteString as B
--import qualified "bytestring" Data.ByteString.Lazy as B

--------------------------------------------------

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

--------------------------------------------------

  go = \case
      FileLocation filepath   -> BS.readFile filepath
      FileContents bytestring -> return bytestring

--------------------------------------------------

-- | wraps ''.

read :: (MonadIO m) =>  -> m (Text)
read () = do

  

  return $ ""

--------------------------------------------------

{-| An in-memory directory (with all its children files).

-}

type UTF8Directory = Directory Text

--------------------------------------------------

{-| An on-disk directory.

-}

type PathDirectory = Directory Void

--------------------------------------------------

{-|

NOTE: the "leaves" of this "file tree" must be 'File's;
thus, empty directories can't be represented (c.f. @git@).

-}

type Directory0 = Directory _

{-|

NOTE: the "leaves" of this "file tree" can be @Nothing@s;
thus, empty directories can be represented.

-}

type Directory1 = Directory _

--------------------------------------------------

data SrcDst = SrcDst

  { input  :: Src
  , output :: Dst
  }

--------------------------------------------------

>>> :set -XImplicitPrelude
>>> toConfig [] == Right defaultConfig
True
>>> toConfig [] == toConfig ["--subdir"]
True
>>> toConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", ".\/my-haskell-project-skeleton"] ])
Right (Config {verbosity = Verbose, filepath = Just ".\/my-haskell-project-skeleton", project = Nothing, subdirectory = PackageInRootDirectory})

:set -XPackageImports
:set -XImplicitPrelude
import qualified "optparse-applicative" Options.Applicative as P
parseConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", "./my-haskell-project-skeleton"] ])

    P.Failure (P.ParserFailure k) -> Left $ show (k "")

-- P.mkCompleter getCompletions

  <*> (P.flag PackageInNamesakeSubdirectory PackageInRootDirectory)
        ( P.long    "--no-subdir"
       <> P.metavar "SUBDIR?"
       <> P.help    "Whether the (singleton-package) project has (the default, without any flag) or doesn't have (with this flag) a separate subdirectory for its package."
       <> P.value
        )

--------------------------------------------------


{-|

-}

pBindingDefault :: Parser Binding
pBindingDefault = pBinding def

--------------------------------------------------

P.failureCode :: Int
 exit code — when a parse error occurs.

P.headerDoc   
P.progDescDoc ""
P.footerDoc   

--------------------------------------------------

data Config f = Config

  { verbosity    :: f Verbosity
  , license      :: f License
  , actions      :: Action f
  }

--------------------------------------------------

{-| 

-}

mkLocation projectpath projectname = getFirst $ sconcat

  [ First projectpath
  , First projectname
  , First def
  ]

--------------------------------------------------

programVersion :: Version
programVersion = Version

  { versionBranch = (majorVersion ++ minorVersion)
  , versionTags   = []
  }

  where

  majorVersion = [0,1]
  minorVersion = [0]

versionBranch = [a,b,c]

--------------------------------------------------

import           "base" Data.Maybe
import           "base" Data.Semigroup

--------------------------------------------------


#	@mkdir -p "./bin/bash_completion.d"
#
#	@touch "./bin/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/$(DefaultExecutableProgram)"
#
#	@touch "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-build "skeletor:exe:$(DefaultExecutableProgram)"
#
#	ln -sf `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` "./bin/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-exec -- $(DefaultExecutableProgram) --bash-completion-script `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` > "./bin/bash_completion.d/$(DefaultExecutableProgram)"

--------------------------------------------------

##################################################
package:

# ^ a package generated by « cabal2nix »'s,
# or any package which looks like: « {mkDerivation, base, ...}: mkDerivation { ... } ».

--------------------------------------------------

{

  cabal-project-file = import ./cabal.project.nix {};

  nix-derviation = import ./skeletor.nix arguments;

}

--------------------------------------------------

static-shell:

	@echo '=================================================='
	@echo

	@$(NixBuild)  "./nix/static"  -o "./result-static"

	@echo
	@echo '=================================================='

.PHONY: static-shell

--------------------------------------------------

arguments@

{ nixpkgs  ? <nixpkgs>
, overlays ? []
, config   ? {}

, pkgs     ? (import nixpkgs { inherit overlays config; }).pkgsMusl
           # ^ « musl » as C Library, not « glibc ».

, compiler ? "ghc844"
           # ^ GHC 8.4.4

, strip    ? true
}:

--------------------------------------------------

cabal error:

    ~/haskell/spiros$ hba
    Resolving dependencies...
    Map.!: given key is not an element in the map
    CallStack (from HasCallStack):
      error, called at libraries/containers/Data/Map/Internal.hs:610:17 in containers-0.5.11.0:Data.Map.Internal

cause: undeclared flag

--------------------------------------------------


options :: P.Parser Options
options = do

  let knownProjectNames = builtinProjectNames

  verbosity <- (P.flag Concise Verbose) (mconcat

        [ embolden (P.long    "verbose")
        , embolden (P.short   'v')
        , P.help    "Enable verbose messages. (Includes printing the config that's derived from the invokation of this command: ① parsing these command-line options; and ② defaulting the values of any optional options)."
        ])

  dryrun <- (P.flag TrueRun DryRun) (mconcat

        [ embolden (P.long    "dryrun")
        , embolden (P.short   'i')
        , P.help    "Whether the execution will just be a 'dry-run' (i.e. effects are disabled, instead they are printed out)."
        ])

  printVersion <- empty

     <|> (P.switch (mconcat

        [ embolden (P.long    "print-version")
        , P.help    "Print the version of this program. The format is, for example, « 0.0.0 ». No other text is printed."
        ]))

     <|> (P.switch (mconcat

        [ embolden (P.long    "version")
        , P.help    "Alias for « --print-version »."
        ]))

  printLicense <- P.switch (mconcat   -- TODO -- subcommand, not option.

        [ embolden (P.long    "print-license")
        , P.help    "Print the SPDX license identifier of this program, then print out the license text."
        ])

  printConfig <- P.switch (mconcat
        [ embolden (P.long    "print-config")
        , P.internal                  -- .hidden
        , P.help    "[INTERNAL] Print the internal configuration which the command-line options are parsed into."
        ])

  resolveConfiguration <- P.switch (mconcat [])

  projectpath <- optional (P.strOption (mconcat

        [ embolden (P.long    "project-filepath")
        , embolden (P.short   'f')
        , italicize (P.metavar "PROJECT_PATH")
        , P.action  "directory"
        , P.help    "Which project skeleton, by path. (When both « --project-filepath » and « --project-name » are given, this option takes precedence. When neither are given, the default value equivalent to « --project-name=default »)."
        ]))

  projectname <- optional (P.strOption (mconcat

        [ embolden (P.long    "project-name")
        , embolden (P.short   'p')
        , italicize (P.metavar "PROJECT_NAME")
        , P.completeWith builtinProjectNames
        , P.help    "Which project skeleton, by name. (Press the « TAB » key for shell-completion of known projects)."
        ]))

  subdirectory <- optional (P.strOption (mconcat
        [ embolden (P.long    "subdir")
        , P.action  "file"
        , P.help    "The subdirectory of the « --location » (when unpacked)."
        ]))

  configpath <- optional (P.strOption (mconcat

        [ embolden (P.long    "config")
        , embolden (P.short   'c')
        , italicize (P.metavar "CONFIG_FILE")
        , P.action  "file"
        , P.help    "Non-Command-Line Options & Arguments — most (but not all) options can be passed via an « INI » file (c.f. a UNIX-style « .conf » file). Relative filepaths are interpreted relative: to ① the current directory from which this command was invoked; ② to the XDG configuraton directories (both global and user). Absolute filepaths are accepted too. NOTE any explicit Command-Line options override any options written in CONFIG_FILE."
        ]))

  bindings <- many (P.option rBinding (mconcat

        [ embolden (P.long    "binding")
        , embolden (P.short   'b')
        , italicize (P.metavar "VARIABLE_BINDING")
        , P.help    "A configuration variable binding. e.g. « -b \"name=Sam Boosalis\" » (NOTE the quotes are stripped from the argument by the shell, they group the « name=value » into a single argument, when the « value » has whitespace.)."
        ]))

  environment <- defaulting [] (P.option rBindings (mconcat

        [ embolden (P.long    "bindings")
        , embolden (P.short   'e')
        , italicize (P.metavar "VARIABLE_BINDING...")
        , P.help    "A set of configuration variable bindings. e.g. « -e 'user=sboosali:name=Sam Boosalis:' ». one « --bindings _ » is equivalent to multiple « --binding _ --binding _ ...»."
        ]))

  license <- defaulting "BSD-3-Clause" (P.strOption (mconcat

        [ embolden (P.long    "license")
        , embolden (P.metavar "LICENSE")
        , P.completeWith knownLicenseIds
        , P.help    "The PROJECTS's spdx license identifier."
        ]))

  return Options{..}

--------------------------------------------------

licenseOption :: License
licenseOption = 
  license <- defaulting "BSD-3-Clause" (P.strOption (mconcat

        [ (P.long    "license")
        , (P.metavar "LICENSE")
        , P.completeWith knownLicenseIds
        , P.help    "The PROJECTS's spdx license identifier."
        , P.style P.bold
        ]))

--------------------------------------------------

  where

  defaulting x p = maybe x id <$> optional p

  embolden  = (<> P.style P.bold)
  italicize = (<> P.style P.underline)

--------------------------------------------------

pCommand :: P.Parser Command
pCommand = empty

  <|> (P.hsubparser (CommandCreateProject        <$> pCreateProjectOptions))
  <|> (P.hsubparser (CommandDownloadProject      <$> pDownloadProjectOptions))
  <|> (P.hsubparser (CommandResolveConfiguration <$> pResolveConfigurationOptions))

--------------------------------------------------

pCommand :: P.Parser Command
pCommand = P.hsubparser p
  where

  p = empty

    <|> (P.command (CommandCreateProject        <$> pCreateProjectOptions))
    <|> (P.command (CommandDownloadProject      <$> pDownloadProjectOptions))
    <|> (P.command (CommandResolveConfiguration <$> pResolveConfigurationOptions))


--------------------------------------------------
-- Parsers ---------------------------------------
--------------------------------------------------

pURI :: P.ReadM URI
pURI = _

--------------------------------------------------

pProject :: P.ReadM Project
pProject = _

--------------------------------------------------

pLicense :: P.ReadM License
pLicense = _

--------------------------------------------------

pLocation :: P.ReadM Location
pLocation = _

--------------------------------------------------

pFetchBy :: P.ReadM FetchBy
pFetchBy = _

--------------------------------------------------

rBindings :: P.ReadM Bindings
rBindings = P.eitherReader (A.parseOnly p . T.pack)
  where

  p = pBindings bindingSyntax

--------------------------------------------------

rBinding :: P.ReadM Binding
rBinding = P.eitherReader (A.parseOnly p . T.pack)
  where

  p = pBinding bindingSyntax

--------------------------------------------------

rLicense :: P.ReadM License
rLicense = P.maybeReader parseSpdxLicenseIdentifier

--------------------------------------------------


parseCommand :: (MonadThrow m) => [String] -> m Command
parseCommand

  = P.execParserPure preferences piCommand
  > fromParserResult
  > either throwM return

  where

  fromParserResult :: P.ParserResult P.ParserHelp -> Either CommandFailure a
  fromParserResult = \case

    P.Success a           -> Right a
    P.Failure e           -> Left (toCommandFailure (P.renderFailure programName e))
    P.CompletionInvoked _ -> Left def

  toCommandFailure :: (String, ExitCode) -> CommandFailure
  toCommandFailure (stderr, exitcode) = CommandFailure{..}

--------------------------------------------------

type Assoc k v = [(k, v)]

--------------------------------------------------

--------------------------------------------------

{-|

-}

newtype Actions = Actions

  [Action]

  deriving stock    (Show)
  deriving stock    (Generic)
  deriving newtype  (Eq,Ord)
  deriving newtype  (Semigroup,Monoid)
  deriving newtype  (NFData)

--------------------------------------------------

-- | 
instance IsList Actions where

  type Item Actions = Action

  fromList = coerce
  toList   = coerce

--------------------------------------------------

--------------------------------------------------
-- CLI Types -------------------------------------
--------------------------------------------------


{-| 

-}

toActions :: (MonadThrow m) => Options -> m Actions
toActions Options{..} = do

  let actions' = actions

  return actions'

  where

  actions :: Actions
  actions = mconcat
    [ (if printVersion then [ActionPrintVersion] else [])
    , (if printLicense then [ActionPrintLicense] else [])
    , []
    ]

--------------------------------------------------

{-| 

-}

runAction :: (MonadThrow m, MonadIO m) => Action -> m Status
runAction = \case

  ActionPrintVersion               -> do

    printVersionWith ()
    return Success

  ActionPrintLicense               -> do

    printLicenseWith ()
    return Success

  ActionCreateProject        input -> do

    result <- (createProjectWith input)
    return (toStatus result)

  ActionDownloadProject      input -> do

    result <- (downloadProjectWith input)
    return (toStatus result)

  ActionResolveConfiguration       -> do

    nothing
    return Success

--------------------------------------------------

runCommand :: Command -> IO ()
runCommand = print

--------------------------------------------------

etags:
	$(Cabal) new-exec -- ghci -e ":etags $(TagsFile)"
	cat $(TagsFile)

.PHONY: etags

--------------------------------------------------

((haskell-mode
  . ((dante-target    . "skeletor:exe:skeletor-haskell")
     (compile-comm

--------------------------------------------------

[![License BSD3](https://img.shields.io/badge/license-BSD3-brightgreen.svg)](http://opensource.org/licenses/BSD-3-Clause)
[![Hackage](https://img.shields.io/hackage/v/modern-uri.svg?style=flat)](https://hackage.haskell.org/package/modern-uri)
[![Stackage Nightly](http://stackage.org/package/modern-uri/badge/nightly)](http://stackage.org/nightly/package/modern-uri)
[![Stackage LTS](http://stackage.org/package/modern-uri/badge/lts)](http://stackage.org/lts/package/modern-uri)
[![Build Status](https://travis-ci.org/mrkkrp/modern-uri.svg?branch=master)](https://travis-ci.org/mrkkrp/modern-uri)

--------------------------------------------------

extra-deps:

- git:     git@github.com:sboosali/spiros.git
  commit:  0158ed5109c8b90c21347180aa84a891276ec007
  subdirs: spiros


--------------------------------------------------
--------------------------------------------------

{-|

-}

data CreateProjectArguments = CreateProjectArguments

  { location    :: Location
  , destination :: FilePath
  }

  deriving stock    (Show,Eq,Ord)
  deriving stock    (Generic)
  deriving anyclass (NFData)

--------------------------------------------------


{- Return the application's (platform-specific) **configuration directory**.

Output:

* is an absolute path
* should be a user-writeable directory.

Conforms to the @XDG BaseDir@s specification.

Environment Variables:

* @$XDG_CONFIG_DIR@ — on POSIX.
* @%LOCALAPPDATA%@  — on Windows.

Notes:

> 

-}

getApplicationSpecificConfigurationDirectory :: FilePath -> IO FilePath
getApplicationSpecificConfigurationDirectory = getApplicationSpecificXdgDirectory Directory.XdgConfig

--------------------------------------------------

{- Return the application's (platform-specific) **data directory**.

Output:

* is an absolute path
* should be a user-writeable directory.

Conforms to the @XDG BaseDir@s specification.

Environment Variables:

* @$XDG_DATA_DIR@  — on POSIX.
* @%LOCALAPPDATA%@ — on Windows.

Notes:

> 

-}

getApplicationSpecificDataDirectory :: FilePath -> IO FilePath
getApplicationSpecificDataDirectory = getApplicationSpecificXdgDirectory Directory.XdgData

--------------------------------------------------

{- Return the application's (platform-specific) **cache directory**.

Output:

* is an absolute path
* should be a user-writeable directory.

Conforms to the @XDG BaseDir@s specification.

Environment Variables:

* @$XDG_CACHE_DIR@ — on POSIX.
* @%TEMP%@         — on Windows.

Notes:

> 

-}

getApplicationSpecificCacheDirectory :: FilePath -> IO FilePath
getApplicationSpecificCacheDirectory = getApplicationSpecificXdgDirectory Directory.XdgCache

--------------------------------------------------

getXdgDirectory :: XdgDirectory         -- ^ which special directory
                -> FilePath             -- ^ a relative path that is appended
                                        --   to the path; if empty, the base
                                        --   path is returned
                -> IO FilePath
getXdgDirectory xdgDir suffix =
  (`ioeAddLocation` "getXdgDirectory") `modifyIOError` do
    simplify . (</> suffix) <$> getXdgDirectoryInternal getHomeDirectory xdgDir


getHomeDirectoryInternal :: IO FilePath
getHomeDirectoryInternal = getEnv "HOME"

getXdgDirectoryInternal :: IO FilePath -> XdgDirectory -> IO FilePath
getXdgDirectoryInternal getHomeDirectory xdgDir = do
  case xdgDir of
    XdgData   -> get "XDG_DATA_HOME"   ".local/share"
    XdgConfig -> get "XDG_CONFIG_HOME" ".config"
    XdgCache  -> get "XDG_CACHE_HOME"  ".cache"
  where
    get name fallback = do
      env <- lookupEnv name
      case env of
        Nothing   -> (</> fallback) <$> getHomeDirectory
        Just path -> pure path

--------------------------------------------------

  let getDefaultPath = Directory.getHomeDirectory <&> (</> suffix)

--------------------------------------------------


getPathFromEnvironmentOrDefault :: IO FilePath -> [String] -> IO FilePath
getPathFromEnvironmentOrDefault getDefaultPath variables = do

  valueDynamicPath <- go

  case valueDynamicPath of

    Nothing -> do
      defaultPath <- getDefaultPath
      pure defaultPath

    Just dynamicPath -> pure dynamicPath

  where

  go = IO.lookupEnv variableDynamicPath

--------------------------------------------------


{-| Return the value of the first environment variable that's been set, or a default value if all are unset.

Examples:

@
> firstEnvironmentVariable "/usr/run" [ "XDG_RUNTIME_HOME", "TMP" ]
@

Properties:

@
firstEnvironmentVariable x [] ≈ return x
@

-}

firstEnvironmentVariable :: String -> [String] -> IO String
firstEnvironmentVariable x vs =

xDefault = First x

xs = vs

foldr x xs



foldr xDefault xs

--------------------------------------------------

eval "$(my-program --bash-completion-script $(which my-program))"

source <(cabal new-run my-program -- --bash-completion-script `which my-program`)

--------------------------------------------------

writeApplicationSpecificCacheFile relativePath fileContents = do

  applicationDirectory <- getApplicationSpecificCacheDirectory 

  file      = applicationDirectory </> relativePath
  directory = Directory. file
  
  createDirectoryIfMissing True directory
  IO.writeFile file fileContents


--------------------------------------------------

TODO make sure symlinks to directories work.

P.completer (P.mkCompleter (completeFilesWithExtension tarballExtensions))

tar
zip
json


completeFilesWithExtension :: [String] -> (String -> IO [String])
completeFilesWithExtension extensions prefix = do

Directory.
File.

--------------------------------------------------

{-| Return the value of the first environment variable that's been set, or a default value if all are unset.

Examples:

@
> firstEnvironmentVariable \"\/usr\/run\" [ \"XDG_RUNTIME_HOME\", \"TMP\" ]
@

Properties:

@
firstEnvironmentVariable x [] ≡ return x
@

-}

firstEnvironmentVariable :: String -> [String] -> IO String
firstEnvironmentVariable x0 ns = do

  x' <- getFirst <$> foldrM go (First (Just x0)) ns

  E.evaluate (Deep.force x')

  x = x' & maybe x0 id

  return x

  where

  go :: String -> First String -> m (First String)
  go n y = do

    x <- lookupEnv n

    let z = First x <> y

    return z

--------------------------------------------------

firstNonemptyEnvironmentVariable :: String -> [String] -> IO String
firstNonemptyEnvironmentVariable x0 ns = do

  x <- getFirst <$> foldrM go (First x0) ns

  E.evaluate (Deep.force x)

  return x

  where

  go :: String -> String -> m String
  go n x = do

    y <- lookupEnv n

    let z = x <> First y

    return z

--------------------------------------------------
firstNumericEnvironmentVariable :: (Num n) => n -> [String] -> IO n
firstNumericEnvironmentVariable n = toNumber $

  firstEnvironmentVariableSatisfying isNumber n

  where

  toNumber = readMaybe > maybe n
  isNumber = readMaybe > maybe False (const True)

--------------------------------------------------

readTextFileWith :: IO FilePath -> IO (Maybe Text)
readTextFileWith getFilePath = do

  absolutePath <- getFilePath

  if IO.doesFileExist absolutePath

  then do
    s <- IO.readFile absolutePath
    let fileContents = T.pack s
    return (Just fileContents)

  else do
    return Nothing

--------------------------------------------------


programVersion :: Version
programVersion = Version.makeVersion (majorVersion ++ minorVersion)

  where

  majorVersion = [0,1]
  minorVersion = [0]

--------------------------------------------------

-- | The current build of this program (a Git commit).

programVersionPatch :: String
programVersionPatch = "" --TODO-- inject current git commit via preprocesser.

--------------------------------------------------

-- | The SPDX License Identifier of this program.

programLicenseIdentifier :: String
programLicenseIdentifier = "__LICENSE__"

--------------------------------------------------

-- | The license of this program (for the user to read).

programLicenseContents :: String
programLicenseContents = "" -- TODO


--------------------------------------------------


--------------------------------------------------
-- Constants -------------------------------------
--------------------------------------------------

-- | The english name of this program.

name_Xxx_Program_xxX :: String
name_Xxx_Program_xxX = (application_Xxx_Program_xxX & name)

--------------------------------------------------

-- | The current version of this program.

version_Xxx_Program_xxX :: Version
version_Xxx_Program_xxX = (application_Xxx_Program_xxX & version)

--------------------------------------------------

-- | The name of this program (as invoked in a terminal).

executable_Xxx_Program_xxX :: String
executable_Xxx_Program_xxX = (application_Xxx_Program_xxX & executable)

-- = "xxx-program-xxx"

--------------------------------------------------
-- Definitions -----------------------------------
--------------------------------------------------

application_Xxx_Program_xxX :: ApplicationInformation
application_Xxx_Program_xxX = ApplicationInformation{..}
  where

  name                  = "My Application"
  version               = "0.0.0"
  license               = "GPL-3.0-or-later"

  executable            = "my-application"
  interface             = ApplicationCLI
  platforms             = [ DesktopPOSIX, DesktopMacintosh ]

  posixSubDirectory     = "myapplication/"
  windowsSubDirectory   = "sboosali/My Application/"
  macintoshSubDirectory = "io.sboosali.My-Application/"


subdirectory_Xxx_Program_xxX :: IO FilePath
subdirectory_Xxx_Program_xxX = do

  platform <- getRuntimeApplicationPlatform

  let directory = subdirectoryOfMyApplicationFor platform

  return directory


--------------------------------------------------


pCommand :: P.Parser Command
pCommand = go (P.hsubparser ps <|> os)
  where

  os = asum

    [ pGlobalOptions
    , pPseudoSubcommands
    ]

  ps = mconcat

    [ (P.command "create" (CommandCreateProject        <$> piCreateProjectOptions))
    , (P.command "fetch"  (CommandDownloadProject      <$> piDownloadProjectOptions))
    , (P.command "config" (CommandResolveConfiguration <$> piResolveConfigurationOptions))
    ]

  go = _


--------------------------------------------------


{-| The (top-level) program invocation; @main@ parses this.

If no subcommand can be parsed, real ('pSubCommand')
or fake ('pPseudoSubcommand'), the parser fails; and
@main@ throws an exception, exiting with exit code @2@.

-}

pCommand :: P.Parser Command
pCommand = do

  options <- pO

  mCommand <- pC

  mCommand & maybe pE (go options)

  where

  pO :: P.Parser GlobalOptions
  pO = pGlobalOptions

  pC :: P.Parser (Maybe Command)
  pC = asum

    [ Just <$> pPseudoSubcommand
    ,          pSubCommand
    ]

  pE :: forall x. P.Parser x
  pE = P.

  go :: GlobalOptions -> Command -> Command
  go options command = _


--------------------------------------------------


addOptionsToCommand :: GlobalOptions -> Command -> Command
addOptionsToCommand options command = case command of

  CommandCreateProject CreateProjectOptions{..} ->

    return CreateProjectOptions{..}

  CommandDownloadProject DownloadProjectOptions{..} ->

    return DownloadProjectOptions{..}

  CommandResolveProject ResolveProjectOptions{..} ->

    return ResolveProjectOptions{..}

  command -> command  


--------------------------------------------------

addOptionsToCommand :: GlobalOptions -> Command -> Command
addOptionsToCommand options = \case

  CommandCreateProject CreateProjectOptions{..} ->

    return CreateProjectOptions{..}

  CommandDownloadProject DownloadProjectOptions{..} ->

    return DownloadProjectOptions{..}

  CommandResolveProject ResolveProjectOptions{..} ->

    return ResolveProjectOptions{..}

  command -> command

--------------------------------------------------


mergeGlobalOptions :: GlobalOptions -> GlobalOptions -> GlobalOptions
mergeGlobalOptions globals1 globals2 = globals
  where

  globals = _ globals1 globals2


--------------------------------------------------

-- | The current version of this program.

xxx_program_xxx_version :: Version
xxx_program_xxx_version = "0.0.0"

--------------------------------------------------











--------------------------------------------------

-- source-repository-package
--       type:     git
--       location: https://github.com/ghcjs/ghcjs-base
--       tag:      01014ade3f8f5ae677df192d7c2a208bd795b96c

--------------------------------------------------
-- LocalFlags (i.e. only for project/vendored packages)
--------------------------------------------------

documentation:            True
haddock-hyperlink-source: True

-- haddock-all: True
-- haddock-internal: true

-- NOTE <<< haddock-all: True >>> implies <<< haddock-executables >>> and <<< haddock-tests >>> and <<< haddock-benchmarks >>>

-- haddock-benchmarks: True
-- haddock-executables: True
-- haddock-tests: True














--------------------------------------------------


{-| The (top-level) program invocation; @main@ parses this.

If no subcommand can be parsed, real ('pSubCommand')
or fake ('pPseudoSubCommand'), the parser fails; and
@main@ throws an exception, exiting with exit code @2@.

-}

pResult :: P.Parser Result
pResult = do

  options <- pO

  mCommand <- pC

  mCommand & maybe pE (go options)

  where

  pO :: P.Parser GlobalOptions
  pO = pGlobalOptions

  pC :: P.Parser (Maybe Command)
  pC = asum

    [ Just <$> pPseudoSubCommand
    ,          pSubCommand
    ]


--------------------------------------------------

getResult :: IO Result
getResult = P.customExecParser preferences piCommand

--------------------------------------------------

parseResult :: (MonadThrow m) => [String] -> m Result
parseResult

  = P.execParserPure preferences piCommand
  > fromParserResult
  > either throwM return


--------------------------------------------------


exitWithHelpTextForCommand :: IO a
exitWithHelpTextForCommand = do

  printHelpTextForCommand

--------------------------------------------------


pPseudoSubCommand :: P.Parser Command
pPseudoSubCommand = do

  mVersion <- (P.flag Nothing (Just CommandPrintVersion)) (mconcat

        [ P.long    "version"
        , P.style  P.bold
        , P.help "Print the version of this program. Format is: dot-separated numberics."
        ])

  mLicense <- (P.flag Nothing (Just CommandPrintLicense)) (mconcat

        [ P.long    "license"
        , P.style  P.bold
        , P.help "Print the license of this program. Format is: an SPDX License Identifier."
        ])

  let mCommand = [ mVersion, mLicense ] & (catMaybes > listToMaybe)

  return mCommand

--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------


--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------
