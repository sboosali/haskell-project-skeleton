--------------------------------------------------

instance (NFData a) => NFData (Files a) where

--------------------------------------------------

deriving anyclass instance (Hashable a) => Hashable (Files a)

--------------------------------------------------

class NFData1 f where

A class of functors that can be fully evaluated.

Since: deepseq-1.4.3.0

liftRnf :: (a -> ()) -> f a -> ()

liftRnf should reduce its argument to normal form (that is, fully evaluate all sub-components), given an argument to reduce a arguments, and then return '()'.

--------------------------------------------------

instance NFData a => NFData [a] where rnf = rnf1

instance NFData1 [] where
    liftRnf r = go
      where
        go [] = ()
        go (x:xs) = r x `seq` go xs

--------------------------------------------------

toEV_byErroring

--------------------------------------------------

instance NFData1 Files where

  liftRnf :: (a -> ()) -> (Files a -> ())
  liftRnf rnf' = go

    where
    go _ = _

--------------------------------------------------

WhiteBlackList

--------------------------------------------------


{-|

'ChiaroscuroFilters' is a pair of filters (a blacklist and a whitelist)
of 'GlobPattern's.

@≡ 'These' 'emptyBlacklist' 'fullWhitelist'@

-}

newtype ChiaroscuroFilters = ChiaroscuroFilters

  (These Blacklist Whitelist)

--------------------------------------------------

{-| 

-}

type FilePathRegex = GlobPattern


--------------------------------------------------

type ChiaroscuroFilter = (Either GlobPattern GlobPattern)

--------------------------------------------------

import "these" Data.These (These(..))

--------------------------------------------------


{-| a blacklisted pattern.

= Implementation

@≡ 'Left'@

-}

blacklist :: GlobPattern -> ChiaroscuroFilter
blacklist = Left

{-| a whitelisted pattern.

= Implementation

@≡ 'Right'@

-}

whitelist :: GlobPattern -> ChiaroscuroFilter
whitelist = Right

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
blacklistChiaroscuroFilter = Set.singleton > go
  where

  go x = ChiaroscuroFilters (Blacklist x) mempty

whitelistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
whitelistChiaroscuroFilter = Set.singleton >
  go
  where

  go x = ChiaroscuroFilters mempty (Whitelist (Just x))

--------------------------------------------------

{-| a 'ChiaroscuroFilter' is a single value marked as either:

* blacklisted; or
* whitelisted.

-}

data ChiaroscuroFilter a = ChiaroscuroFilter

  { blacklisted :: !a
  , whitelisted :: !a
  }

  deriving stock    (Functor,Foldable,Traversable)

  deriving stock    (Generic,Lift)
  deriving stock    (Show,Read,Eq,Ord)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
blacklistChiaroscuroFilter = 

--------------------------------------------------

whitelistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
whitelistChiaroscuroFilter = 

--------------------------------------------------

{-| (utility function)

-}

fromFileKind
  :: FileKind
  -> (GlobPattern -> [FilePattern])

fromFileKind = \case

  RegularFile   -> RegularPattern   > (:[])
  DirectoryFile -> DirectoryPattern > (:[])
  AnyFile       -> mkBoth

  where
  mkBoth :: GlobPattern -> [FilePattern]
  mkBoth s = [RegularPattern s, DirectoryPattern s]

--------------------------------------------------

data FileKind

  = RegularFile
  | DirectoryFile
  | AnyFile

--------------------------------------------------

filterFilePaths :: FilePathFilters -> FindClause FilePath -> FindClause Bool
filterFilePaths = \case

  This  bs    -> filterBlacklist bs
  That  ws    -> filterWhitelist ws
  These bs ws -> filterBlacklist bs &&? filterWhitelist ws

--------------------------------------------------

filterFilesClause
  :: FileFilters
  -> (FindClause FilePath -> FindClause Bool)

filterFilesClause (ChiaroscuroFilters{ chiaroscuroBlacklist, chiaroscuroWhitelist }) =

  filterBlacklist chiaroscuroBlacklist &&? filterWhitelist chiaroscuroWhitelist

filterBlacklistClause
  :: Blacklist
  -> (FindClause FilePath -> FindClause Bool)

filterBlacklistClause (Blacklist bs) = go bs
  where

  go blacklist = \filepath ->

    all (filepath /~?) blacklist

filterWhitelistClause
  :: Whitelist
  -> (FindClause FilePath -> FindClause Bool)

filterWhitelistClause = \case

  Nothing             -> const (pure True)

  Just (Whitelist ws) -> go ws
  where

  go whitelist = \filepath ->

    any (filepath ~~?) whitelist

--------------------------------------------------

import qualified "containers" Data.Set as Set
import           "containers" Data.Set (Set)

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

import qualified "bytestring" Data.ByteString as B
--import qualified "bytestring" Data.ByteString.Lazy as B

--------------------------------------------------

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

--------------------------------------------------

  go = \case
      FileLocation filepath   -> BS.readFile filepath
      FileContents bytestring -> return bytestring

--------------------------------------------------

-- | wraps ''.

read :: (MonadIO m) =>  -> m (Text)
read () = do

  

  return $ ""

--------------------------------------------------

{-| An in-memory directory (with all its children files).

-}

type UTF8Directory = Directory Text

--------------------------------------------------

{-| An on-disk directory.

-}

type PathDirectory = Directory Void

--------------------------------------------------

{-|

NOTE: the "leaves" of this "file tree" must be 'File's;
thus, empty directories can't be represented (c.f. @git@).

-}

type Directory0 = Directory _

{-|

NOTE: the "leaves" of this "file tree" can be @Nothing@s;
thus, empty directories can be represented.

-}

type Directory1 = Directory _

--------------------------------------------------

data SrcDst = SrcDst

  { input  :: Src
  , output :: Dst
  }

--------------------------------------------------

>>> :set -XImplicitPrelude
>>> toConfig [] == Right defaultConfig
True
>>> toConfig [] == toConfig ["--subdir"]
True
>>> toConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", ".\/my-haskell-project-skeleton"] ])
Right (Config {verbosity = Verbose, filepath = Just ".\/my-haskell-project-skeleton", project = Nothing, subdirectory = PackageInRootDirectory})

:set -XPackageImports
:set -XImplicitPrelude
import qualified "optparse-applicative" Options.Applicative as P
parseConfig (concat [ ["-v"],  ["--no-subdir"], ["-f", "./my-haskell-project-skeleton"] ])

    P.Failure (P.ParserFailure k) -> Left $ show (k "")

-- P.mkCompleter getCompletions

  <*> (P.flag PackageInNamesakeSubdirectory PackageInRootDirectory)
        ( P.long    "--no-subdir"
       <> P.metavar "SUBDIR?"
       <> P.help    "Whether the (singleton-package) project has (the default, without any flag) or doesn't have (with this flag) a separate subdirectory for its package."
       <> P.value
        )

--------------------------------------------------


{-|

-}

pBindingDefault :: Parser Binding
pBindingDefault = pBinding def

--------------------------------------------------

P.failureCode :: Int
 exit code — when a parse error occurs.

P.headerDoc   
P.progDescDoc ""
P.footerDoc   

--------------------------------------------------

data Config f = Config

  { verbosity    :: f Verbosity
  , license      :: f License
  , actions      :: Action f
  }

--------------------------------------------------

{-| 

-}

mkLocation projectpath projectname = getFirst $ sconcat

  [ First projectpath
  , First projectname
  , First def
  ]

--------------------------------------------------

programVersion :: Version
programVersion = Version

  { versionBranch = (majorVersion ++ minorVersion)
  , versionTags   = []
  }

  where

  majorVersion = [0,1]
  minorVersion = [0]

versionBranch = [a,b,c]

--------------------------------------------------

import           "base" Data.Maybe
import           "base" Data.Semigroup

--------------------------------------------------


#	@mkdir -p "./bin/bash_completion.d"
#
#	@touch "./bin/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/$(DefaultExecutableProgram)"
#
#	@touch "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#	@chmod 700 "./bin/bash_completion.d/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-build "skeletor:exe:$(DefaultExecutableProgram)"
#
#	ln -sf `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` "./bin/$(DefaultExecutableProgram)"
#
#	$(Cabal) new-exec -- $(DefaultExecutableProgram) --bash-completion-script `$(Cabal) new-exec which -- $(DefaultExecutableProgram)` > "./bin/bash_completion.d/$(DefaultExecutableProgram)"

--------------------------------------------------

##################################################
package:

# ^ a package generated by « cabal2nix »'s,
# or any package which looks like: « {mkDerivation, base, ...}: mkDerivation { ... } ».

--------------------------------------------------

{

  cabal-project-file = import ./cabal.project.nix {};

  nix-derviation = import ./skeletor.nix arguments;

}

--------------------------------------------------

static-shell:

	@echo '=================================================='
	@echo

	@$(NixBuild)  "./nix/static"  -o "./result-static"

	@echo
	@echo '=================================================='

.PHONY: static-shell

--------------------------------------------------

arguments@

{ nixpkgs  ? <nixpkgs>
, overlays ? []
, config   ? {}

, pkgs     ? (import nixpkgs { inherit overlays config; }).pkgsMusl
           # ^ « musl » as C Library, not « glibc ».

, compiler ? "ghc844"
           # ^ GHC 8.4.4

, strip    ? true
}:

--------------------------------------------------

cabal error:

    ~/haskell/spiros$ hba
    Resolving dependencies...
    Map.!: given key is not an element in the map
    CallStack (from HasCallStack):
      error, called at libraries/containers/Data/Map/Internal.hs:610:17 in containers-0.5.11.0:Data.Map.Internal

cause: undeclared flag

--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------
