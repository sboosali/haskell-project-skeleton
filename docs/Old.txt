--------------------------------------------------

instance (NFData a) => NFData (Files a) where

--------------------------------------------------

deriving anyclass instance (Hashable a) => Hashable (Files a)

--------------------------------------------------

class NFData1 f where

A class of functors that can be fully evaluated.

Since: deepseq-1.4.3.0

liftRnf :: (a -> ()) -> f a -> ()

liftRnf should reduce its argument to normal form (that is, fully evaluate all sub-components), given an argument to reduce a arguments, and then return '()'.

--------------------------------------------------

instance NFData a => NFData [a] where rnf = rnf1

instance NFData1 [] where
    liftRnf r = go
      where
        go [] = ()
        go (x:xs) = r x `seq` go xs

--------------------------------------------------

toEV_byErroring

--------------------------------------------------

instance NFData1 Files where

  liftRnf :: (a -> ()) -> (Files a -> ())
  liftRnf rnf' = go

    where
    go _ = _

--------------------------------------------------

WhiteBlackList

--------------------------------------------------


{-|

'ChiaroscuroFilters' is a pair of filters (a blacklist and a whitelist)
of 'GlobPattern's.

@≡ 'These' 'emptyBlacklist' 'fullWhitelist'@

-}

newtype ChiaroscuroFilters = ChiaroscuroFilters

  (These Blacklist Whitelist)

--------------------------------------------------

{-| 

-}

type FilePathRegex = GlobPattern


--------------------------------------------------

type ChiaroscuroFilter = (Either GlobPattern GlobPattern)

--------------------------------------------------

import "these" Data.These (These(..))

--------------------------------------------------


{-| a blacklisted pattern.

= Implementation

@≡ 'Left'@

-}

blacklist :: GlobPattern -> ChiaroscuroFilter
blacklist = Left

{-| a whitelisted pattern.

= Implementation

@≡ 'Right'@

-}

whitelist :: GlobPattern -> ChiaroscuroFilter
whitelist = Right

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
blacklistChiaroscuroFilter = Set.singleton > go
  where

  go x = ChiaroscuroFilters (Blacklist x) mempty

whitelistChiaroscuroFilter :: (Ord a) => a -> (ChiaroscuroFilters a)
whitelistChiaroscuroFilter = Set.singleton >
  go
  where

  go x = ChiaroscuroFilters mempty (Whitelist (Just x))

--------------------------------------------------

{-| a 'ChiaroscuroFilter' is a single value marked as either:

* blacklisted; or
* whitelisted.

-}

data ChiaroscuroFilter a = ChiaroscuroFilter

  { blacklisted :: !a
  , whitelisted :: !a
  }

  deriving stock    (Functor,Foldable,Traversable)

  deriving stock    (Generic,Lift)
  deriving stock    (Show,Read,Eq,Ord)
  deriving anyclass (NFData,Hashable)

--------------------------------------------------

blacklistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
blacklistChiaroscuroFilter = 

--------------------------------------------------

whitelistChiaroscuroFilter :: (Ord a) => a -> ChiaroscuroFilter a
whitelistChiaroscuroFilter = 

--------------------------------------------------

{-| (utility function)

-}

fromFileKind
  :: FileKind
  -> (GlobPattern -> [FilePattern])

fromFileKind = \case

  RegularFile   -> RegularPattern   > (:[])
  DirectoryFile -> DirectoryPattern > (:[])
  AnyFile       -> mkBoth

  where
  mkBoth :: GlobPattern -> [FilePattern]
  mkBoth s = [RegularPattern s, DirectoryPattern s]

--------------------------------------------------

data FileKind

  = RegularFile
  | DirectoryFile
  | AnyFile

--------------------------------------------------

filterFilePaths :: FilePathFilters -> FindClause FilePath -> FindClause Bool
filterFilePaths = \case

  This  bs    -> filterBlacklist bs
  That  ws    -> filterWhitelist ws
  These bs ws -> filterBlacklist bs &&? filterWhitelist ws

--------------------------------------------------

filterFilesClause
  :: FileFilters
  -> (FindClause FilePath -> FindClause Bool)

filterFilesClause (ChiaroscuroFilters{ chiaroscuroBlacklist, chiaroscuroWhitelist }) =

  filterBlacklist chiaroscuroBlacklist &&? filterWhitelist chiaroscuroWhitelist

filterBlacklistClause
  :: Blacklist
  -> (FindClause FilePath -> FindClause Bool)

filterBlacklistClause (Blacklist bs) = go bs
  where

  go blacklist = \filepath ->

    all (filepath /~?) blacklist

filterWhitelistClause
  :: Whitelist
  -> (FindClause FilePath -> FindClause Bool)

filterWhitelistClause = \case

  Nothing             -> const (pure True)

  Just (Whitelist ws) -> go ws
  where

  go whitelist = \filepath ->

    any (filepath ~~?) whitelist

--------------------------------------------------

import qualified "containers" Data.Set as Set
import           "containers" Data.Set (Set)

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

import qualified "bytestring" Data.ByteString as B
--import qualified "bytestring" Data.ByteString.Lazy as B

--------------------------------------------------

import qualified "text"       Data.Text    as T
import qualified "text"       Data.Text.IO as T

--------------------------------------------------

  go = \case
      FileLocation filepath   -> BS.readFile filepath
      FileContents bytestring -> return bytestring

--------------------------------------------------

-- | wraps ''.

read :: (MonadIO m) =>  -> m (Text)
read () = do

  

  return $ ""

--------------------------------------------------

{-| An in-memory directory (with all its children files).

-}

type UTF8Directory = Directory Text

--------------------------------------------------

{-| An on-disk directory.

-}

type PathDirectory = Directory Void

--------------------------------------------------

{-|

NOTE: the "leaves" of this "file tree" must be 'File's;
thus, empty directories can't be represented (c.f. @git@).

-}

type Directory0 = Directory _

{-|

NOTE: the "leaves" of this "file tree" can be @Nothing@s;
thus, empty directories can be represented.

-}

type Directory1 = Directory _

--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------



--------------------------------------------------
